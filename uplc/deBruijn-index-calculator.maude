fmod INDEX-CALCULATOR is 
    pr UPLC .
    pr CONVERSION .
    pr BUILTINS-FUNCTIONS .

    sorts NormalizedTerm IndexedTerm Stack Pair Map .
    subsort Pair < Stack .
    subsort Pair < Map .

    op emptyMap : -> Map [ctor] .
    op _/_ : Map Map -> Map [ctor assoc comm id: emptyMap] .

    op notFound : -> Pair [ctor] .
    op (_|_) : String String -> Pair [ctor] .
    op emptyStack : -> Stack [ctor] .
    op _:_ : Stack Stack -> Stack [ctor assoc id: emptyStack] .

    op _/_/_/_ : UplcTerm Int Stack Map -> IndexedTerm [ctor] .

    op _/_ : Map UplcTerm -> NormalizedTerm [ctor] .


    var P : Program .
    vars T T' T'' T''' : UplcTerm .
    var V : Version .
    vars I I' I'' : Int .
    var CT : ConstantType .
    var BN : BuiltName .
    vars S S' S'' : String .
    vars St St' St'' : Stack .
    var Pr : Pair .
    vars CL CL' : ConList .
    vars M M' M'' : Map .
    var C : Con .

    op put : Map Pair -> Map .
    eq put(emptyMap, Pr) = Pr .
    eq put((S | S'') / M, (S | S')) = (S | S') / M .
    eq put(M , (S | S')) = (S | S') / M  [owise] .

    op updateMap : Map Map -> Map .
    eq updateMap(M, emptyMap) = M .
    ceq updateMap(M, (S | S') / M') = updateMap(M'', M')
        if M'' := put(M, (S | S')) .

    op findInMap : Map UplcTerm -> Pair .
    eq findInMap ((S | S') / M, S) = (S | S') .
    eq findInMap(M, T) = notFound [owise] .

    op push : Stack Pair -> Stack .
    eq push(emptyStack, Pr) = Pr .
    eq push(St, Pr) = Pr : St .

    op pop : Stack -> Stack .
    eq pop(emptyStack) = emptyStack .
    eq pop(Pr : St) = St .

    op find : Stack String -> Pair .
    eq find(emptyStack, S) = notFound .
    eq find((S | S') : St, S) = (S | S') .
    eq find(Pr : St, S) = find(St, S) [owise] .

    op calculateIndex : Program -> Program .
    ceq calculateIndex((program V T)) = (program V T') 
        if T' / I / St / M := calculateIndex(T, 0, emptyStack, emptyMap) .

    op calculateIndex : UplcTerm Int Stack Map -> IndexedTerm .

    eq calculateIndex(((con CT)), I, St, M) = ((con CT)) / I / St / M .

    eq calculateIndex(((builtin BN)), I, St, M) = calculateIndex( getFunction(BN), I, St, M) .

    ceq calculateIndex(((BN CL)), I , St, M) = ((BN CL')) / I / St / M
        if CL' := calculateIndexInConList(CL, St) .

    ceq calculateIndex(((lam S T)), I, St, M) = ((lam S' T')) / I' / St'' / M''
        if S' := appendIndex(S, I)
        /\ St' := push(St, (S | S'))
        /\ M' := put(M, (S' | S))
        /\ T' / I' / St'' / M'' := calculateIndex(T, s(I), St', M') .

    ceq calculateIndex([T T'], I, St, M) = [T'' T'''] / I'' / St'' / M''
        if T'' / I' / St' / M' := calculateIndex(T, I, St, M) 
        /\ T''' / I'' / St'' / M'' := calculateIndex(T', I', St, M') .

    ceq calculateIndex(((delay T)), I, St, M) = ((delay T')) / I' / St' / M'
        if T' / I' / St' / M' := calculateIndex(T, I, St, M) .

    ceq calculateIndex(((force T)), I, St, M) = ((force T')) / I' / St' / M'
        if T' / I' / St' / M' := calculateIndex(T, I, St, M) .    

    eq calculateIndex(((error)), I, St, M) = ((error)) / I / St / M .

    ceq calculateIndex(S, I, St, M) = S'' / I / pop(St) / M
        if (S' | S'') := find(St, S) .

    --- Free Variable
    --- ceq calculateIndex(S, I, St) = S / I / St 
    ---     if find(St, S) == notFound [print "Variable " I " is free"] .

    op calculateIndexInConList : ConList Stack -> ConList .
    eq calculateIndexInConList(emptyConList, St) = emptyConList .
    ceq calculateIndexInConList(((C CL)), St) = S'' calculateIndexInConList(CL, St)
        if (S' | S'') := find(St, C) .
    eq calculateIndexInConList((C CL), St) = C calculateIndexInConList(CL, St) [owise] .

    op appendIndex : String Int -> String .
    eq appendIndex(S, I) = S + "_" + string(I, 10) .


    op normalizeIndex : UplcTerm Map -> UplcTerm .
    eq normalizeIndex((con CT), M) = (con CT) .
    eq normalizeIndex((builtin BN), M) = (builtin BN) .
    eq normalizeIndex((error), M) = (error) .
    eq normalizeIndex([T T'], M) = [normalizeIndex(T, M) normalizeIndex(T', M)] .
    eq normalizeIndex((delay T), M) = (delay normalizeIndex(T, M)) .
    eq normalizeIndex((force T), M) = (force normalizeIndex(T, M)) .
    ceq normalizeIndex(S, M) = S''
        if ( S' | S'' ) := findInMap(M, S) .
    ceq normalizeIndex((lam S T), M) = (lam S'' normalizeIndex(T, M))
        if ( S' | S'' ) := findInMap(M, S) .
    eq normalizeIndex((BN CL), M) = (BN normalizeIndexInConList(M, CL)) .

    op normalizeIndexInConList : Map ConList -> ConList .
    eq normalizeIndexInConList(M, emptyConList) = emptyConList .
    ceq normalizeIndexInConList(M, (C CL)) = S' normalizeIndexInConList(M, CL) 
        if (S | S') := findInMap(M, C) .
    eq normalizeIndexInConList(M, (C CL)) = C normalizeIndexInConList(M, CL) [owise] .
        --- if findInMap(M, T) == notFound .

    op normalizeAndCalculateIndex : Map UplcTerm -> NormalizedTerm .
    ceq normalizeAndCalculateIndex(M, T) = M' / T''
        if T' := normalizeIndex(T, M)
        /\ T'' / I / St / M' := calculateIndex(T', 0, emptyStack, emptyMap) .
    eq normalizeAndCalculateIndex(M, T) = M / (error) [owise print "ERROOOOR " M "\n\n" T "\n\n\n\n"].

endfm