fmod TERM-REDUCTOR2 is 
    pr UPLC .
    pr BUILTINS-FUNCTIONS .
    pr INDEX-CALCULATOR .

    sort ForcesToDelete .

    op _//_ : UplcTerm Nat -> ForcesToDelete [ctor] .

    vars T T' T'' T''' IT IT' : UplcTerm .
    var CT : ConstantType .
    vars S S' : String .
    var BN : BuiltName .
    vars CL CL' : ConList .
    vars N  N' : Nat .
    var CO : ConstanOperation .
    vars M M' M'' M''' : Map .

    op executeTerm : UplcTerm Map -> NormalizedTerm .
    ceq executeTerm((con CT), M) = updateMap(M, M') / T
        if M' / T := normalizeAndCalculateIndex(M, (con CT)) .

    ceq executeTerm((error), M) = updateMap(M, M') / T
        if M' / T := normalizeAndCalculateIndex(M, (error)) .

    ceq executeTerm((delay T), M) = updateMap(M, M') / T'
        if M' / T' := normalizeAndCalculateIndex(M, (delay T)) .

    ceq executeTerm((lam S T), M) = updateMap(M, M') / T'
        if M' / T' := normalizeAndCalculateIndex(M, (lam S T)) .

    ceq executeTerm((force T), M) = executeTerm(T'', updateMap(M, M'))
        if  M' / IT := normalizeAndCalculateIndex(M, (force T))
        /\ T' // N := executeForce(IT, 0, M) 
        /\ T'' := deleteDelay(T', N) .

    ceq executeTerm([T T'], M) = executeNormalizedApply(IT, updateMap(M, M') )
        if M' / IT := normalizeAndCalculateIndex(M, [T T']) .

    ceq executeTerm(CO, M) = updateMap(M, M')  / evaluate(T')  
        if M' / T' := normalizeAndCalculateIndex(M, CO) .

    ceq executeTerm(S, M) = updateMap(M, M')  / T'
        if M' / T' := normalizeAndCalculateIndex(M,  S) .

    eq executeTerm(T, M) = M / (error) [owise print "OTRO " T] .

    op executeNormalizedApply : UplcTerm Map -> NormalizedTerm .
    ceq executeNormalizedApply([T T'], M) = updateMap(M'', M') / IT'
        if M' / IT := executeTerm(T', M) 
        /\ M''' / IT' := normalizeAndCalculateIndex(updateMap(M, M'), [T IT])
        /\ T'' := replaceTermNormalizedApply(IT', M''')
        /\ M'' / IT' := executeTerm(T'', updateMap(M', M'''))  .
    
    op replaceTermNormalizedApply : UplcTerm Map -> UplcTerm .
    ceq replaceTermNormalizedApply([T T'], M) = T''
        if T'' := replaceTerm(T, T', M) [print "si puedo " T " - " T' " result " T''].

    op replaceTerm : UplcTerm UplcTerm Map -> UplcTerm .
    ceq replaceTerm((lam S T), T', M) = T''
        if T'' := replaceTermInLambda(T, T', S) .
    ceq replaceTerm([T T'], T'', M) = replaceTerm(IT, T'', updateMap(M, M'))
        if M' / IT := executeTerm([T T'], M) .
    ceq replaceTerm((force T), T', M) = replaceTerm(IT, T', updateMap(M, M')) 
        if M' / IT := executeTerm((force T), M) .
    eq replaceTerm(T, T', M) = T [owise print "no puedo " T " - " T'] .

    op replaceTermInLambda : UplcTerm UplcTerm String -> UplcTerm .
    ceq replaceTermInLambda(S, T, S') = T
        if S == S' .
    ceq replaceTermInLambda(S, T, S') = S
        if S =/= S' .
    eq replaceTermInLambda((BN CL), T, S) = (BN replaceTermInConList(CL, T, S)) .
    eq replaceTermInLambda((con CT), T, S') = (con CT) .
    eq replaceTermInLambda((error), T, S') = (error) .
    eq replaceTermInLambda((lam S T), T', S') = (lam S replaceTermInLambda(T, T', S')) .
    ceq replaceTermInLambda((delay T), T', S) = T''
        if T'' := (delay replaceTermInLambda(T, T', S)) .
    eq replaceTermInLambda((force T), T', S) = (force replaceTermInLambda(T, T', S))  .
    ceq replaceTermInLambda([T T'], T'', S) = T'''
        if T''' := [replaceTermInLambda(T, T'', S) replaceTermInLambda(T', T'', S)] .

    op replaceTermInConList : ConList UplcTerm String -> ConList .
    eq replaceTermInConList(emptyConList, T, S) = emptyConList .
    eq replaceTermInConList((CL S CL'), T, S) = CL T CL' .
    eq replaceTermInConList((CL), T, S) = CL [owise] .

    op executeForce : UplcTerm Nat Map -> ForcesToDelete .
    eq executeForce((delay T), N, M) = T // N .
    ceq executeForce((force T), N, M) = executeForce(T, N', M) 
        if N' := s(N) .
    ceq executeForce(T, N, M) = deleteDelay(T', 1) // N
        if M' / T' := executeTerm(T, M) 
        /\ T' :: Delay .

    op deleteDelay : UplcTerm Nat -> UplcTerm .
    eq deleteDelay(T, 0) = T .
    eq deleteDelay((delay T), N) = deleteDelay(T, N - 1) [owise] .
endfm