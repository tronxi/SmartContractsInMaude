fmod UPLC-PROCESS-MODULE is
    pr META-LEVEL .
    pr LEXICAL .
    pr INT .

    var FM : FModule .
    var LT : TermList .
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var ODS : OpDeclSet .
    var MAS : MembAxSet .
    var EqS : EquationSet .
    var Eq : Equation .
    var OD : OpDecl .
    vars T T' T'' T''' : Term .
    vars S S' S'' S''' : String .
    var N : Nat .
    var Q : Qid .
    var L : Letters .
    vars I I' I'' : Int .

    sort Letters .
    subsort String < Letters .

    op _,_ : Letters Letters -> Letters [ctor assoc comm] .

    op letters : -> Letters .
    eq letters = "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", 
                "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
                "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
                "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" .

    op numbers : -> Letters .
    eq numbers = "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" .

    op validVersionChar : -> Letters .
    eq validVersionChar = numbers, "." .
    
    op validVarChar : -> Letters .
    eq validVarChar = letters , numbers .

    op validHexadecimalChar : -> Letters .
    eq validHexadecimalChar = numbers , "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F" .

    op Qid : -> [Qid] [ctor] .

    op processModule : FModule Term -> FModule .
    eq processModule(FM, T) = addEquation(FM, eq 'program.Program = parseProgram(T) [none] .) .

    op parseProgram : Term -> Term .
    eq parseProgram('`(program__`)['token[T],T']) = '`(program__`)[parseVersion(T),parseTerm(T')] .

    op parseVersion : Term -> Term .
    ceq parseVersion(T) = '`(_._._`)[T',T'',T'''] 
        if Q := downTerm(T, Qid)
        /\ S := string(Q)
        /\ allVersionCharAreValid(S, 0)
        /\ I := find(S, ".", 0)
        /\ I' := find(S, ".", s(I))
        /\ S' := "\"" + cleanZeros(substr(S, 0, I)) + "\".sString" 
        /\ S'' := "\"" + cleanZeros(substr(S, s(I), sd(sd(I',1), I))) + "\".sString" 
        /\ S''' := "\"" + cleanZeros(substr(S, s(I'), sd(sd(length(S),1), I'))) + "\".sString"
        /\ T' := getTerm(metaReduce(uplc, 'qidToInt:_[tokenize(S')]))
        /\ T'' := getTerm(metaReduce(uplc, 'qidToInt:_[tokenize(S'')]))
        /\ T''' := getTerm(metaReduce(uplc, 'qidToInt:_[tokenize(S''')])) .

    op allVersionCharAreValid : String Int -> Bool .
    ceq allVersionCharAreValid(S, I) = isValidVersionChar(S') 
        and allVersionCharAreValid(S, s(I)) 
        if S' := substr(S, I, 1)
        /\ I < length(S) .
    eq allVersionCharAreValid(S, I) = true [owise] .

    op isValidVersionChar : String -> Bool .
    eq isValidVersionChar(S) = containInLetters(S, validVersionChar) .

    op cleanZeros : String -> String .
    ceq cleanZeros(S) = S
        if startWithZero(S)
        /\ length(S) == 1 .
    ceq cleanZeros(S) = cleanZeros(S')
        if startWithZero(S)
        /\ S' := substr(S, 1, length(S)) .
    eq cleanZeros(S) = S [owise] .

    op startWithZero : String -> Bool .
    ceq startWithZero(S) = S' == "0"
        if S' := substr(S, 0, 1) .

    op parseTerm : Term -> Term .
    eq parseTerm('`(con__`)['token[''integer.Qid],'token[T]]) = '`(con__`)['integer.Atn, parseTermToIntTerm(T)] .
    eq parseTerm('`(con__`)['token[''string.Qid],'token[T]]) = '`(con__`)['string.Atn, parseTermToStringTerm(T)] .
    eq parseTerm('`(con__`)['token[''bool.Qid],'token[''True.Qid]]) = '`(con__`)['bool.Atn,'True.Constant] .
    eq parseTerm('`(con__`)['token[''bool.Qid],'token[''False.Qid]]) = '`(con__`)['bool.Atn,'False.Constant] .
    eq parseTerm('`(con__`)['token[''unit.Qid],'token[''`(`).Qid]]) = '`(con__`)['unit.Atn,'unit.Constant] .
    eq parseTerm('`(con__`)['token[''bytestring.Qid],'token[T]]) = '`(con__`)['bytestring.Atn,parseTermToByteStringTerm(T)] .
    eq parseTerm('`(builtin_`)['token[T]]) = '`(builtin_`)[parseBuiltinName(T)] .
    eq parseTerm('`(lam__`)['token[T],T']) = '`(lam__`)[parseVarTerm(T),parseTerm(T')] .
    eq parseTerm('`[__`][T,T']) = '`[__`][parseTerm(T),parseTerm(T')] .
    eq parseTerm('`(delay_`)[T]) = '`(delay_`)[parseTerm(T)] .
    eq parseTerm('`(force_`)[T]) = '`(force_`)[parseTerm(T)] .
    eq parseTerm('`(error`).@Term@) = '`(error`).Term .
    eq parseTerm('token[T]) = parseVarTerm(T) .
    op parseTermToIntTerm : Term -> Term .
    ceq parseTermToIntTerm(T) = getTerm(metaReduce(uplc, 'qidToInt:_[T']))
        if Q := downTerm(T, Qid)
            /\ S := "\"" + string(Q) + "\".sString" 
            /\ T' := tokenize(S) .

    op uplc : -> FModule .
    eq uplc = upModule('UPLC, false) .

    op parseTermToStringTerm : Term -> Term .
    ceq parseTermToStringTerm(T) = tokenize(S)
        if Q := downTerm(T, Qid)
            /\ S := string(Q) + ".String" .

    op parseVarTerm : Term -> Term .
    ceq parseVarTerm(T) = T 
        if Q := downTerm(T, Qid) 
        /\ S := string(Q)
        /\ startWithLetter(S)
        /\ allVarCharAreValid(S, 0) .

    op startWithLetter : String -> Bool .
    ceq startWithLetter(S) = containInLetters(S', letters) 
        if S' := substr(S, 0, 1) .

    op allVarCharAreValid : String Int -> Bool .
    ceq allVarCharAreValid(S, I) = isValidVarChar(S') 
        and allVarCharAreValid(S, s(I)) 
        if S' := substr(S, I, 1)
        /\ I < length(S) .
    eq allVarCharAreValid(S, I) = true [owise] .

    op isValidVarChar : String -> Bool .
    eq isValidVarChar(S) = containInLetters(S, validVarChar) .

    op containInLetters : String Letters -> Bool .
    eq containInLetters(S, (S, L)) = true .
    eq containInLetters(S, L) = false [owise] .

    op parseTermToByteStringTerm : Term -> Term .
    ceq parseTermToByteStringTerm(T) = tokenize(S')
        if Q := downTerm(T, Qid)
            /\ S := string(Q)
            /\ startWithHash(S)
            /\ bytestringLengthIsPar(S)
            /\ allHexadecimalCharAreValid(S, 1)
            /\ S' := "\"" + S + "\".String" .

    op startWithHash : String -> Bool .
    ceq startWithHash(S) = S' == "#"
        if S' := substr(S, 0, 1) .

    op bytestringLengthIsPar : String -> Bool .
    ceq bytestringLengthIsPar(S) = (I' rem 2) == 0
        if I := length(S)
        /\ I' := sd(I,1) .

    op allHexadecimalCharAreValid : String Int -> Bool .
    ceq allHexadecimalCharAreValid(S, I) = isValidHexadecimalChar(S') 
        and allHexadecimalCharAreValid(S, s(I)) 
        if S' := substr(S, I, 1)
        /\ I < length(S) .
    eq allHexadecimalCharAreValid(S, I) = true [owise] .

    op isValidHexadecimalChar : String -> Bool .
    eq isValidHexadecimalChar(S) = containInLetters(S, validHexadecimalChar) .

    op parseBuiltinName : Term -> Term .
    ceq parseBuiltinName(T) = tokenize(S')
    if Q := downTerm(T, Qid)
        /\ S := string(Q) + ".BuiltName"
        /\ S' := cleanBuiltinName(S) .

    op cleanBuiltinName : String -> String .
    ceq cleanBuiltinName(S) = S
        if containUnserscore(S) = notFound .
    ceq cleanBuiltinName(S) = cleanBuiltinName(S')
        if N := containUnserscore(S)
        /\ S' := substr(S, 0, N) + "-" + substr(S, N + 1, length(S)) [owise] .

    op containUnserscore : String -> FindResult .
    eq containUnserscore(S) = find(S, "_", 0) .

    op addEquation : FModule Equation -> FModule .
    eq addEquation(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, Eq)
        = fmod H is IL sorts SS . SSDS ODS MAS (EqS Eq) endfm .
endfm