fmod UPLC-PROCESS-MODULE is
    pr META-LEVEL .
    pr LEXICAL .
    pr INT .
    pr CONVERSION .
    pr AUX-MODULE-OPS .

    var FM : FModule .
    vars T T' T'' T''' : Term .
    vars S S' S'' S''' : String .
    var N : Nat .
    var Q : Qid .
    var L : Letters .
    vars I I' : Int .

    sort Letters .
    subsort String < Letters .

    op _,_ : Letters Letters -> Letters [ctor assoc comm] .

    op letters : -> Letters .
    eq letters = "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", 
                "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
                "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
                "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" .

    op numbers : -> Letters .
    eq numbers = "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" .

    op validVersionChar : -> Letters .
    eq validVersionChar = numbers, "." .
    
    op validVarChar : -> Letters .
    eq validVarChar = letters , numbers, "_", "'" .

    op validHexadecimalChar : -> Letters .
    eq validHexadecimalChar = numbers , "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F" .

    op Qid : -> [Qid] [ctor] .

    op uplcProcessModule : FModule Term -> FModule .
    eq uplcProcessModule(FM, T) = addEquation(FM, eq 'program.Program = parseProgram(T) [none] .) .

    op parseProgram : Term -> Term .
    eq parseProgram('`(program__`)['token[T],T']) = '`(program__`)[parseVersion(T),parseTerm(T')] .

    op parseVersion : Term -> Term .
    ceq parseVersion(T) = '`(_._._`)[T',T'',T'''] 
        if Q := downTerm(T, Qid)
        /\ S := string(Q)
        /\ allVersionCharAreValid(S, 0)
        /\ I := find(S, ".", 0)
        /\ I' := find(S, ".", s(I))
        /\ S' := cleanZeros(substr(S, 0, I))
        /\ S'' := cleanZeros(substr(S, s(I), sd(sd(I',1), I)))
        /\ S''' := cleanZeros(substr(S, s(I'), sd(sd(length(S),1), I')))
        /\ T' := upTerm(rat(S', 10))
        /\ T'' := upTerm(rat(S'', 10))
        /\ T''' := upTerm(rat(S''', 10)) .

    op allVersionCharAreValid : String Int -> Bool .
    ceq allVersionCharAreValid(S, I) = isValidVersionChar(S') 
        and allVersionCharAreValid(S, s(I)) 
        if S' := substr(S, I, 1)
        /\ I < length(S) .
    eq allVersionCharAreValid(S, I) = true [owise] .

    op isValidVersionChar : String -> Bool .
    eq isValidVersionChar(S) = containInLetters(S, validVersionChar) .

    op cleanZeros : String -> String .
    ceq cleanZeros(S) = S
        if startWithZero(S)
        /\ length(S) == 1 .
    ceq cleanZeros(S) = cleanZeros(S')
        if startWithZero(S)
        /\ S' := substr(S, 1, length(S)) .
    eq cleanZeros(S) = S [owise] .

    op startWithZero : String -> Bool .
    ceq startWithZero(S) = S' == "0"
        if S' := substr(S, 0, 1) .

    op parseTerm : Term -> Term .
    eq parseTerm('`(con__`)['token[''integer.Qid],'token[T]]) = '`(con_`)['__['integer.Atn, parseTermToIntTerm(T)]].
    eq parseTerm('`(con__`)['token[''string.Qid],'token[T]]) = '`(con_`)['__['string.Atn, parseTermToStringTerm(T)]] .
    eq parseTerm('`(con__`)['token[''bool.Qid],'token[''True.Qid]]) = '`(con_`)['__['bool.Atn,'true.Bool]] .
    eq parseTerm('`(con__`)['token[''bool.Qid],'token[''False.Qid]]) = '`(con_`)['__['bool.Atn,'false.Bool]] .
    eq parseTerm('`(con__`)['token[''unit.Qid],'`(`).@Token@]) = '`(con_`)['__['unit.Atn,'unit.Unit]] .
    eq parseTerm('`(con__`)['token[''bytestring.Qid],'token[T]]) = '`(con_`)['__['bytestring.Atn,parseTermToByteStringTerm(T)]].
    eq parseTerm('`(builtin_`)['token[T]]) = '`(builtin_`)[parseBuiltinName(T)] .
    eq parseTerm('`(lam__`)['token[T],T']) = '`(lam__`)[parseVarTerm(T),parseTerm(T')] .
    eq parseTerm('`[__`][T,T']) = '`[__`][parseTerm(T),parseTerm(T')] .
    eq parseTerm('`(delay_`)[T]) = '`(delay_`)[parseTerm(T)] .
    eq parseTerm('`(force_`)[T]) = '`(force_`)[parseTerm(T)] .
    eq parseTerm('`(error`).@Term@) = '`(error`).Term .
    eq parseTerm('token[T]) = parseVarTerm(T) .

    op parseTermToIntTerm : Term -> Term .
    ceq parseTermToIntTerm(T) = T'
        if Q := downTerm(T, Qid)
            /\ S := cleanZeros(string(Q))
            /\ T' := upTerm(rat(S, 10)) .

    op uplc : -> FModule .
    eq uplc = upModule('UPLC, false) .

    op parseTermToStringTerm : Term -> Term .
    ceq parseTermToStringTerm(T) = tokenize(S)
        if Q := downTerm(T, Qid)
            /\ S := string(Q) + ".String" .

    op parseVarTerm : Term -> Term .
    ceq parseVarTerm(T) = upTerm(S) 
        if Q := downTerm(T, Qid) 
        /\ S := string(Q)
        /\ startWithLetter(S)
        /\ allVarCharAreValid(S, 0) .

    op startWithLetter : String -> Bool .
    ceq startWithLetter(S) = containInLetters(S', letters) 
        if S' := substr(S, 0, 1) .

    op allVarCharAreValid : String Int -> Bool .
    ceq allVarCharAreValid(S, I) = isValidVarChar(S') 
        and allVarCharAreValid(S, s(I)) 
        if S' := substr(S, I, 1)
        /\ I < length(S) .
    eq allVarCharAreValid(S, I) = true [owise] .

    op isValidVarChar : String -> Bool .
    eq isValidVarChar(S) = containInLetters(S, validVarChar) .

    op containInLetters : String Letters -> Bool .
    eq containInLetters(S, (S, L)) = true .
    eq containInLetters(S, L) = false [owise] .

    op parseTermToByteStringTerm : Term -> Term .
    ceq parseTermToByteStringTerm(T) = tokenize(S')
        if Q := downTerm(T, Qid)
            /\ S := string(Q)
            /\ startWithHash(S)
            /\ bytestringLengthIsPar(S)
            /\ allHexadecimalCharAreValid(S, 1)
            /\ S' := "\"" + S + "\".String" .

    op startWithHash : String -> Bool .
    ceq startWithHash(S) = S' == "#"
        if S' := substr(S, 0, 1) .

    op bytestringLengthIsPar : String -> Bool .
    ceq bytestringLengthIsPar(S) = (I' rem 2) == 0
        if I := length(S)
        /\ I' := sd(I,1) .

    op allHexadecimalCharAreValid : String Int -> Bool .
    ceq allHexadecimalCharAreValid(S, I) = isValidHexadecimalChar(S') 
        and allHexadecimalCharAreValid(S, s(I)) 
        if S' := substr(S, I, 1)
        /\ I < length(S) .
    eq allHexadecimalCharAreValid(S, I) = true [owise] .

    op isValidHexadecimalChar : String -> Bool .
    eq isValidHexadecimalChar(S) = containInLetters(S, validHexadecimalChar) .

    op parseBuiltinName : Term -> Term .
    ceq parseBuiltinName(T) = tokenize(S')
    if Q := downTerm(T, Qid)
        /\ S := string(Q) + ".BuiltName"
        /\ S' := cleanBuiltinName(S) .

    op cleanBuiltinName : String -> String .
    ceq cleanBuiltinName(S) = S
        if containUnserscore(S) = notFound .
    ceq cleanBuiltinName(S) = cleanBuiltinName(S')
        if N := containUnserscore(S)
        /\ S' := substr(S, 0, N) + "-" + substr(S, N + 1, length(S)) [owise] .

    op containUnserscore : String -> FindResult .
    eq containUnserscore(S) = find(S, "_", 0) .
endfm